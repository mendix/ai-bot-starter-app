// This file was generated by Mendix Studio Pro.
//
// WARNING: Code you write here will be lost the next time you deploy the project.

package synthiaconnector.proxies.microflows;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;

public final class Microflows
{
	/**
	 * Private constructor to prevent instantiation of this class. 
	 */
	private Microflows() {}

	// These are the microflows for the SynthiaConnector module
	/**
	 * Microflow can be used to invoke a chat completions API with a more complex request where a list of (historical) messages comprising the conversation so far is sent as part of the request.
	 * Inputs:
	 * - Request: Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder chatCompletions_Execute_WithHistoryBuilder(
		genaicommons.proxies.Request _request,
		genaicommons.proxies.Connection _connection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.ChatCompletions_Execute_WithHistory");
		builder = builder.withParam("Request", _request);
		builder = builder.withParam("Connection", _connection);
		return builder;
	}

	/**
	 * Microflow can be used to invoke a chat completions API with a more complex request where a list of (historical) messages comprising the conversation so far is sent as part of the request.
	 * Inputs:
	 * - Request: Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 */
	public static genaicommons.proxies.Response chatCompletions_Execute_WithHistory(
		IContext context,
		genaicommons.proxies.Request _request,
		genaicommons.proxies.Connection _connection
	)
	{
		Object result = chatCompletions_Execute_WithHistoryBuilder(
				_request,
				_connection
			)
			.execute(context);
		return result == null ? null : genaicommons.proxies.Response.initialize(context, (IMendixObject) result);
	}
	/**
	 * Microflow can be used to invoke a chat completions API with a simple request where only a single user message is sent. If you want to send multiple historical user or assistant messages, use the ChatCompletions_Execute_WithHistory microflow.
	 * Inputs:
	 * - UserPrompt: This is the user input.
	 * - Request (optional): Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 * - FileCollection (optional): Currently not supported by this operation!
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder chatCompletions_Execute_WithoutHistoryBuilder(
		genaicommons.proxies.Connection _connection,
		java.lang.String _userPrompt,
		genaicommons.proxies.Request _request,
		genaicommons.proxies.FileCollection _fileCollection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.ChatCompletions_Execute_WithoutHistory");
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("UserPrompt", _userPrompt);
		builder = builder.withParam("Request", _request);
		builder = builder.withParam("FileCollection", _fileCollection);
		return builder;
	}

	/**
	 * Microflow can be used to invoke a chat completions API with a simple request where only a single user message is sent. If you want to send multiple historical user or assistant messages, use the ChatCompletions_Execute_WithHistory microflow.
	 * Inputs:
	 * - UserPrompt: This is the user input.
	 * - Request (optional): Contains messages and optional attributes.
	 * - Connection: Configuration object that contains endpoint and API key. The SynthiaConnection specialization pointing to a ConfigurationTextGeneration must be passed.
	 * - FileCollection (optional): Currently not supported by this operation!
	 */
	public static genaicommons.proxies.Response chatCompletions_Execute_WithoutHistory(
		IContext context,
		genaicommons.proxies.Connection _connection,
		java.lang.String _userPrompt,
		genaicommons.proxies.Request _request,
		genaicommons.proxies.FileCollection _fileCollection
	)
	{
		Object result = chatCompletions_Execute_WithoutHistoryBuilder(
				_connection,
				_userPrompt,
				_request,
				_fileCollection
			)
			.execute(context);
		return result == null ? null : genaicommons.proxies.Response.initialize(context, (IMendixObject) result);
	}
	/**
	 * Use this operation to add chunks to a knowledge base. This operation handles a batch of chunks with their metadata in a single operation.
	 * 
	 * This operation takes care of the creation of the actual tables if needed. Duplications of chunks are not handled by this operation (neither when passing duplicates in the ChunkCollection nor checking an existing knowledge base prior to inserting).
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder chunkCollection_Embed_InsertBuilder(
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_Insert");
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("ChunkCollection", _chunkCollection);
		return builder;
	}

	/**
	 * Use this operation to add chunks to a knowledge base. This operation handles a batch of chunks with their metadata in a single operation.
	 * 
	 * This operation takes care of the creation of the actual tables if needed. Duplications of chunks are not handled by this operation (neither when passing duplicates in the ChunkCollection nor checking an existing knowledge base prior to inserting).
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean chunkCollection_Embed_Insert(
		IContext context,
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection
	)
	{
		Object result = chunkCollection_Embed_InsertBuilder(
				_connection,
				_chunkCollection
			)
			.execute(context);
		return (boolean) result;
	}
	/**
	 * Use this operation to replace existing chunks in a knowledge base based on the MxObjectID. This operation handles a batch of KnowledgebaseChunks in a ChunkCollection with their metadata in a single operation.
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as a ChunkCollection.
	 * In order to replace the right data in the knowledge base, all chunks in ChunkCollection need a MxObjectID: existing chunks related to those Mendix objects will be deleted from the knowledge base first, and then be inserted according to the new state as specified by the ChunkCollection (metadata included).
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder chunkCollection_Embed_ReplaceBuilder(
		genaicommons.proxies.ChunkCollection _chunkCollection,
		genaicommons.proxies.Connection _connection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_Replace");
		builder = builder.withParam("ChunkCollection", _chunkCollection);
		builder = builder.withParam("Connection", _connection);
		return builder;
	}

	/**
	 * Use this operation to replace existing chunks in a knowledge base based on the MxObjectID. This operation handles a batch of KnowledgebaseChunks in a ChunkCollection with their metadata in a single operation.
	 * Use ChunkCollection_Create and ChunkCollection_AddKnowledgeBaseChunk to construct the input for this microflow, which needs to be passed as a ChunkCollection.
	 * In order to replace the right data in the knowledge base, all chunks in ChunkCollection need a MxObjectID: existing chunks related to those Mendix objects will be deleted from the knowledge base first, and then be inserted according to the new state as specified by the ChunkCollection (metadata included).
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean chunkCollection_Embed_Replace(
		IContext context,
		genaicommons.proxies.ChunkCollection _chunkCollection,
		genaicommons.proxies.Connection _connection
	)
	{
		Object result = chunkCollection_Embed_ReplaceBuilder(
				_chunkCollection,
				_connection
			)
			.execute(context);
		return (boolean) result;
	}
	/**
	 * Use this operation to (re-)populate a whole knowledge base with a ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 * 
	 * If the knowlege base already contains data, it will be removed before inserting the KnowledgeBaseChunks of the ChunkCollection.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder chunkCollection_Embed_RepopulateKnowledgeBaseBuilder(
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.ChunkCollection_Embed_RepopulateKnowledgeBase");
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("ChunkCollection", _chunkCollection);
		return builder;
	}

	/**
	 * Use this operation to (re-)populate a whole knowledge base with a ChunkCollection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 * 
	 * If the knowlege base already contains data, it will be removed before inserting the KnowledgeBaseChunks of the ChunkCollection.
	 */
	public static boolean chunkCollection_Embed_RepopulateKnowledgeBase(
		IContext context,
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection
	)
	{
		Object result = chunkCollection_Embed_RepopulateKnowledgeBaseBuilder(
				_connection,
				_chunkCollection
			)
			.execute(context);
		return (boolean) result;
	}
	/**
	 * Converts the configuration string into a configuration object. 
	 * Overwrites an existing configuration with the same ID.
	 * 
	 * Can be used in microflows, for instance After Startup.
	 * 
	 * Throws an error if the input is not valid.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder configuration_RegisterByStringBuilder(
		java.lang.String _configurationString
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.Configuration_RegisterByString");
		builder = builder.withParam("ConfigurationString", _configurationString);
		return builder;
	}

	/**
	 * Converts the configuration string into a configuration object. 
	 * Overwrites an existing configuration with the same ID.
	 * 
	 * Can be used in microflows, for instance After Startup.
	 * 
	 * Throws an error if the input is not valid.
	 */
	public static void configuration_RegisterByString(
		IContext context,
		java.lang.String _configurationString
	)
	{
		configuration_RegisterByStringBuilder(
				_configurationString
			)
			.execute(context);
	}
	/**
	 * This operation takes a collection of text chunks and calculates an embedding vector with the model specified in the configuration for each chunk. 
	 * 
	 * It requires a GenAICommons.Connection object as well as a GenAICommons.ChunkCollection object connected to the collection of GenAICommons.Chunk objects as input and optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder embeddings_Execute_ChunkCollectionBuilder(
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection,
		genaicommons.proxies.EmbeddingsOptions _embeddingsOptions
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.Embeddings_Execute_ChunkCollection");
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("ChunkCollection", _chunkCollection);
		builder = builder.withParam("EmbeddingsOptions", _embeddingsOptions);
		return builder;
	}

	/**
	 * This operation takes a collection of text chunks and calculates an embedding vector with the model specified in the configuration for each chunk. 
	 * 
	 * It requires a GenAICommons.Connection object as well as a GenAICommons.ChunkCollection object connected to the collection of GenAICommons.Chunk objects as input and optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static genaicommons.proxies.EmbeddingsResponse embeddings_Execute_ChunkCollection(
		IContext context,
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.ChunkCollection _chunkCollection,
		genaicommons.proxies.EmbeddingsOptions _embeddingsOptions
	)
	{
		Object result = embeddings_Execute_ChunkCollectionBuilder(
				_connection,
				_chunkCollection,
				_embeddingsOptions
			)
			.execute(context);
		return result == null ? null : genaicommons.proxies.EmbeddingsResponse.initialize(context, (IMendixObject) result);
	}
	/**
	 * This operation takes a single string and calculates an embedding vector with the model specified in the configuration for the InputText.
	 * 
	 * It requires a GenAICommons.Connection object as well as a string, optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder embeddings_Execute_StringBuilder(
		genaicommons.proxies.Connection _connection,
		java.lang.String _inputText,
		genaicommons.proxies.EmbeddingsOptions _embeddingsOptions
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.Embeddings_Execute_String");
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("InputText", _inputText);
		builder = builder.withParam("EmbeddingsOptions", _embeddingsOptions);
		return builder;
	}

	/**
	 * This operation takes a single string and calculates an embedding vector with the model specified in the configuration for the InputText.
	 * 
	 * It requires a GenAICommons.Connection object as well as a string, optionally a GenAICommons.EmbeddingsOptions object. A GenAICommons.EmbeddingsResponse object is being returned. 
	 * 
	 * The connection object should be created by using the microflow "SynthiaConnection_Create" with a configuration of type "Embeddings" or "Knowledge Base".
	 */
	public static genaicommons.proxies.EmbeddingsResponse embeddings_Execute_String(
		IContext context,
		genaicommons.proxies.Connection _connection,
		java.lang.String _inputText,
		genaicommons.proxies.EmbeddingsOptions _embeddingsOptions
	)
	{
		Object result = embeddings_Execute_StringBuilder(
				_connection,
				_inputText,
				_embeddingsOptions
			)
			.execute(context);
		return result == null ? null : genaicommons.proxies.EmbeddingsResponse.initialize(context, (IMendixObject) result);
	}
	/**
	 * Use this operation to delete a complete knowledge base at once. 
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder knowledgeBase_DeleteBuilder(
		genaicommons.proxies.Connection _connection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.KnowledgeBase_Delete");
		builder = builder.withParam("Connection", _connection);
		return builder;
	}

	/**
	 * Use this operation to delete a complete knowledge base at once. 
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a Knowledgebase Configuration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base.
	 */
	public static boolean knowledgeBase_Delete(
		IContext context,
		genaicommons.proxies.Connection _connection
	)
	{
		Object result = knowledgeBase_DeleteBuilder(
				_connection
			)
			.execute(context);
		return (boolean) result;
	}
	/**
	 * Use this operation to retrieve chunks from the knowledge base. The retrieval is based on similarity with respect to the input string (Content) provided.  This operation returns a list of KnowledgeBaseChunk. The returned list is sorted on vector similarity which is handled internally.
	 * Additional filtering can be done by specifying the optional input parameters:
	 * -MinimumSimilarity (in the range 0-1.0): acts as a cut-off: chunks are not retrieved if they have a similarity below this value.
	 * -MaxNumberOfResults: determines the max number of similar chunks that are returned.
	 * -MetadataCollection: when provided, this operation only returns chunks that are conform with all of the metadata key/value pairs in the collection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a KnowledgebaseConfiguration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base. 
	 * The TargetChunk entity (type parameter) must be a specialization of the KnowledgeBaseChunk entity from the GenAICommons. If it contains associations to (specializations of) the related mendix object for which the chunk was created originally, this will be set by this operation for easy processing afterwards.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder knowledgeBaseChunkList_Embed_RetrieveNearestNeighborsBuilder(
		java.lang.String _content,
		java.math.BigDecimal _minimumSimilarity,
		java.lang.Long _maxNumberOfResults,
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.MetadataCollection _metadataCollection
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.KnowledgeBaseChunkList_Embed_RetrieveNearestNeighbors");
		builder = builder.withParam("Content", _content);
		builder = builder.withParam("MinimumSimilarity", _minimumSimilarity);
		builder = builder.withParam("MaxNumberOfResults", _maxNumberOfResults);
		builder = builder.withParam("Connection", _connection);
		builder = builder.withParam("MetadataCollection", _metadataCollection);
		return builder;
	}

	/**
	 * Use this operation to retrieve chunks from the knowledge base. The retrieval is based on similarity with respect to the input string (Content) provided.  This operation returns a list of KnowledgeBaseChunk. The returned list is sorted on vector similarity which is handled internally.
	 * Additional filtering can be done by specifying the optional input parameters:
	 * -MinimumSimilarity (in the range 0-1.0): acts as a cut-off: chunks are not retrieved if they have a similarity below this value.
	 * -MaxNumberOfResults: determines the max number of similar chunks that are returned.
	 * -MetadataCollection: when provided, this operation only returns chunks that are conform with all of the metadata key/value pairs in the collection.
	 * 
	 * The Connection entity passed must be of type SynthiaConnection and must contain the KnowledgeBaseName string attribute filled and a KnowledgebaseConfiguration associated with the connection details to the knowledge base service. By providing the KnowledgeBaseName on the Connection, you determine the knowledge base. 
	 * The TargetChunk entity (type parameter) must be a specialization of the KnowledgeBaseChunk entity from the GenAICommons. If it contains associations to (specializations of) the related mendix object for which the chunk was created originally, this will be set by this operation for easy processing afterwards.
	 */
	public static java.util.List<genaicommons.proxies.KnowledgeBaseChunk> knowledgeBaseChunkList_Embed_RetrieveNearestNeighbors(
		IContext context,
		java.lang.String _content,
		java.math.BigDecimal _minimumSimilarity,
		java.lang.Long _maxNumberOfResults,
		genaicommons.proxies.Connection _connection,
		genaicommons.proxies.MetadataCollection _metadataCollection
	)
	{
		Object result = knowledgeBaseChunkList_Embed_RetrieveNearestNeighborsBuilder(
				_content,
				_minimumSimilarity,
				_maxNumberOfResults,
				_connection,
				_metadataCollection
			)
			.execute(context);
		return result == null ? null : com.mendix.utils.ListUtils.map((java.util.List<IMendixObject>) result, obj -> genaicommons.proxies.KnowledgeBaseChunk.initialize(context, obj));
	}
	/**
	 * Opens the configuration overview page to view and edit configurations.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder nAV_ConfigurationOverview_OpenBuilder()
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.NAV_ConfigurationOverview_Open");
		return builder;
	}

	/**
	 * Opens the configuration overview page to view and edit configurations.
	 */
	public static void nAV_ConfigurationOverview_Open(IContext context)
	{
		nAV_ConfigurationOverview_OpenBuilder().execute(context);
	}
	/**
	 * Creates a non-persistable connection that contains a configuration. This will be used as input for operations.
	 */
	public static com.mendix.core.actionmanagement.MicroflowCallBuilder synthiaConnection_CreateBuilder(
		synthiaconnector.proxies.Configuration _configuration,
		java.lang.String _knowledgeBaseName
	)
	{
		com.mendix.core.actionmanagement.MicroflowCallBuilder builder = Core.microflowCall("SynthiaConnector.SynthiaConnection_Create");
		builder = builder.withParam("Configuration", _configuration);
		builder = builder.withParam("KnowledgeBaseName", _knowledgeBaseName);
		return builder;
	}

	/**
	 * Creates a non-persistable connection that contains a configuration. This will be used as input for operations.
	 */
	public static synthiaconnector.proxies.SynthiaConnection synthiaConnection_Create(
		IContext context,
		synthiaconnector.proxies.Configuration _configuration,
		java.lang.String _knowledgeBaseName
	)
	{
		Object result = synthiaConnection_CreateBuilder(
				_configuration,
				_knowledgeBaseName
			)
			.execute(context);
		return result == null ? null : synthiaconnector.proxies.SynthiaConnection.initialize(context, (IMendixObject) result);
	}
}
